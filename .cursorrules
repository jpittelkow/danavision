# DanaVision Development Guidelines

This file defines critical rules that MUST be followed when making changes to DanaVision.

---

## STOP: Read This First

Before writing ANY code, understand these requirements. Changes will be rejected if not met.

### Quick Checklist

- [ ] Containers are running - Check Docker containers first
- [ ] Tests are written - Every feature/bugfix requires tests
- [ ] Tests pass - Run full test suite before completion
- [ ] E2E tests pass - Frontend features require Playwright tests
- [ ] ADR created - If this is a significant architectural change
- [ ] Documentation created - ALWAYS create/update documentation for all changes
- [ ] Code review performed - Review recently created code for quality
- [ ] Documentation validated - Verify code matches documentation

---

## ⚠️ CRITICAL: Containerized Development Environment

**This project runs ENTIRELY in Docker containers. NOTHING runs locally on the host machine.**

### Before Running ANY Command

1. **Check that containers are running first:**
   ```bash
   docker compose ps
   ```

2. **If containers are not running, start them:**
   ```bash
   docker compose up -d
   ```

### Running Commands

All commands (tests, artisan, npm, composer, etc.) MUST be executed inside containers:

```bash
# Backend commands (PHP/Laravel)
docker compose exec app php artisan migrate
docker compose exec app ./vendor/bin/pest
docker compose exec app composer install

# Frontend commands (Node/npm)
docker compose exec app npm install
docker compose exec app npm run dev
docker compose exec app npm run test:e2e

# Database access
docker compose exec db mysql -u root -p
```

### NEVER Do This

```bash
# WRONG - These will fail or affect wrong environment
php artisan migrate          # No local PHP
./vendor/bin/pest           # No local vendor
npm install                 # Wrong node_modules location
composer install            # No local composer
```

### Common Container Commands

```bash
# View logs
docker compose logs -f app

# Restart containers
docker compose restart

# Rebuild containers (after Dockerfile changes)
docker compose up -d --build

# Shell into container
docker compose exec app bash
```

---

## Mandatory Requirements

### 1. Tests Are Required

EVERY new feature, bug fix, or change MUST include tests. No exceptions.

| Change Type | Backend Test | E2E Test | Required |
|-------------|-------------|----------|----------|
| New page | Pest PHP feature test | Playwright spec | Always |
| New API endpoint | Pest PHP feature test | If UI uses it | Always |
| Bug fix | Regression test | If UI affected | Always |
| New component | - | Playwright if interactive | Always |
| AI/Service change | Pest PHP unit test | - | Always |

### Running Tests

```bash
# Backend tests (Pest PHP) - run inside container
docker compose exec app ./vendor/bin/pest

# E2E tests (Playwright) - requires app running
docker compose exec app npm run test:e2e

# E2E with UI mode (debugging)
docker compose exec app npm run test:e2e:ui
```

### 2. Frontend Testing with Playwright

ALL new frontend features MUST have E2E tests before being considered complete.

- Tests live in `backend/e2e/`
- Use `auth.setup.ts` for authenticated tests
- Test both desktop and mobile viewports
- Cover happy path and error states

### 3. User-Based Data Isolation

All data is scoped to the authenticated user. Users can ONLY access their own data.

**Required Patterns:**

```php
// CORRECT - Filter by authenticated user
$lists = ShoppingList::where('user_id', $request->user()->id)->get();

// WRONG - Never return all records
$lists = ShoppingList::all(); // SECURITY VULNERABILITY!
```

**Policy Authorization:**

```php
// CORRECT - Always authorize with policy
public function show(ShoppingList $list)
{
    $this->authorize('view', $list);
    // ...
}

// WRONG - Never skip authorization
public function show(ShoppingList $list)
{
    return $list; // Any user can view any list!
}
```

### 4. API Contract Synchronization

These files MUST stay synchronized:

1. `backend/resources/js/types/index.ts` - TypeScript interfaces
2. `backend/app/Http/Resources/*.php` - API Resources (if used)
3. `backend/app/Http/Controllers/*Controller.php` - Controller responses

When adding a new field:
1. Add column to migration
2. Add to model's `$fillable`
3. Add to controller response
4. Add to TypeScript interface

### 5. ADRs for Significant Changes

ADRs MUST be written for:
- New features with new patterns
- Database schema changes
- Authentication/authorization changes
- New external integrations
- AI system changes
- Infrastructure changes

Location: `docs/adr/`

### 6. Code Review of Recently Created Code

After writing ANY code, you MUST perform a thorough code review. This is mandatory, not optional.

**Code Review Checklist:**

1. **Security Review**
   - Check for SQL injection vulnerabilities
   - Verify user authorization on all endpoints
   - Ensure no sensitive data is exposed
   - Validate all user inputs

2. **Code Quality Review**
   - Check for proper error handling
   - Verify naming conventions are followed
   - Look for code duplication
   - Ensure functions are single-purpose
   - Check for proper typing (TypeScript/PHP)

3. **Performance Review**
   - Check for N+1 query issues
   - Verify efficient database queries
   - Look for unnecessary computations
   - Check for memory leaks in frontend

4. **Consistency Review**
   - Ensure code matches existing patterns in codebase
   - Verify coding style consistency
   - Check that similar problems are solved similarly

**How to Perform Code Review:**

```bash
# Review recent changes
git diff HEAD~1

# Review specific files
git diff <file_path>
```

### 7. Documentation Validation

All code MUST be validated against existing documentation. Code and documentation must stay in sync.

**Validation Requirements:**

1. **Before Implementation**
   - Read existing documentation for the feature area
   - Understand documented patterns and conventions
   - Check ADRs for relevant architectural decisions

2. **During Implementation**
   - Follow documented patterns exactly
   - If deviating from documentation, update documentation first
   - Cross-reference TypeScript types with API documentation

3. **After Implementation**
   - Verify code behavior matches documentation
   - Run examples from documentation to confirm they work
   - Update any outdated documentation discovered

**Documentation Locations to Check:**
- `docs/` - General documentation
- `docs/adr/` - Architectural Decision Records
- `README.md` - Project overview
- Code comments and docblocks
- TypeScript interfaces in `backend/resources/js/types/`

### 8. Mandatory Documentation Creation

Documentation MUST be created for EVERY change. This is non-negotiable.

**What Requires Documentation:**

| Change Type | Documentation Required |
|-------------|------------------------|
| New feature | Feature docs, usage examples, TypeScript types |
| New API endpoint | API docs with request/response examples |
| Bug fix | Update existing docs if behavior changed |
| New component | Component docs with props and usage |
| Database change | Migration docs, model relationship docs |
| Configuration change | Environment/config documentation |

**Documentation Standards:**

1. **Inline Documentation**
   ```php
   /**
    * Calculate the total price for all items in the shopping list.
    *
    * @param ShoppingList $list The shopping list to calculate
    * @return float The total price including tax
    * @throws InvalidListException If list contains invalid items
    */
   public function calculateTotal(ShoppingList $list): float
   ```

2. **TypeScript JSDoc**
   ```typescript
   /**
    * Fetches shopping list data from the API.
    * @param listId - The unique identifier of the shopping list
    * @returns Promise resolving to the shopping list data
    * @throws {ApiError} When the list is not found or user is unauthorized
    */
   async function fetchList(listId: string): Promise<ShoppingList>
   ```

3. **README Updates**
   - Update feature list when adding features
   - Add setup instructions for new dependencies
   - Document new environment variables

4. **ADR Creation**
   - Create ADR for any architectural decision
   - Include context, decision, and consequences
   - Link to related ADRs

**Documentation Template for New Features:**

```markdown
# Feature Name

## Overview
Brief description of what this feature does.

## Usage
How to use this feature with code examples.

## API Reference
Endpoints, parameters, and responses.

## Examples
Real-world usage examples.

## Related
Links to related features or documentation.
```

---

## Code Patterns

### Controller Actions

```php
// Index - filter by user
public function index(Request $request)
{
    $items = ShoppingList::where('user_id', $request->user()->id)->get();
    return Inertia::render('Lists/Index', ['lists' => $items]);
}

// Store - set user_id from auth
public function store(Request $request)
{
    $validated = $request->validate([...]);
    $list = ShoppingList::create([
        'user_id' => $request->user()->id,
        ...$validated,
    ]);
    return redirect()->route('lists.show', $list);
}

// Show/Update/Delete - authorize with policy
public function show(ShoppingList $list)
{
    $this->authorize('view', $list);
    return Inertia::render('Lists/Show', ['list' => $list]);
}
```

### Policy Pattern

```php
class ShoppingListPolicy
{
    public function view(User $user, ShoppingList $list): bool
    {
        return $user->id === $list->user_id;
    }

    public function update(User $user, ShoppingList $list): bool
    {
        return $user->id === $list->user_id;
    }
}
```

### Inertia.js Patterns

```tsx
// Page component with typed props
interface Props extends PageProps {
  list: ShoppingList;
  can_edit: boolean;
}

export default function ListShow({ auth, list, can_edit, flash }: Props) {
  const { data, setData, post, processing } = useForm({
    product_name: '',
  });

  const submit = (e: FormEvent) => {
    e.preventDefault();
    post(`/lists/${list.id}/items`);
  };

  return (
    <AppLayout auth={auth} flash={flash}>
      {/* ... */}
    </AppLayout>
  );
}
```

---

## Pre-Completion Checklist

Before marking ANY feature as complete:

1. [ ] Containers running: `docker compose ps`
2. [ ] Backend tests pass: `docker compose exec app ./vendor/bin/pest`
3. [ ] E2E tests pass: `docker compose exec app npm run test:e2e`
4. [ ] New features have E2E tests in `backend/e2e/`
5. [ ] TypeScript types updated if API changed
6. [ ] No console.log/debug statements left
7. [ ] Error handling uses proper messages
8. [ ] Loading states handled in UI
9. [ ] **Code review completed** - Review all new code for quality, security, and consistency
10. [ ] **Documentation created** - All new code has proper documentation
11. [ ] **Documentation validated** - Code behavior matches existing documentation
12. [ ] **Inline docs added** - PHPDoc/JSDoc comments on all public methods
13. [ ] **README updated** - If feature affects project setup or usage

---

## Testing New Features

When implementing a new feature:

1. Verify containers are running: `docker compose ps`
2. **Read existing documentation** for the feature area
3. Write the backend code with inline documentation (PHPDoc)
4. Write Pest PHP tests for the controller/service
5. Write the frontend React component with JSDoc comments
6. Write Playwright E2E tests
7. Run all tests (inside container): `docker compose exec app ./vendor/bin/pest`
8. Fix any failures
9. **Perform code review** of all newly written code
10. **Create/update documentation** for the feature
11. **Validate code against documentation** - ensure they match
12. Feature is complete only when ALL tests pass AND documentation is complete

---

## Questions?

1. Are containers running? `docker compose ps`
2. Check if the pattern exists elsewhere in the codebase
3. Look for user_id filtering pattern
4. Verify Policy authorization is in place
5. Run tests - they catch many issues

---

## ⚠️ MANDATORY: Code Review & Documentation Workflow

This workflow is REQUIRED after writing any code. Do not skip these steps.

### Step 1: Code Review (After Every Code Change)

```
┌─────────────────────────────────────────────────────────────┐
│                    CODE REVIEW CHECKLIST                    │
├─────────────────────────────────────────────────────────────┤
│ □ Security: No vulnerabilities, proper auth, input validated│
│ □ Quality: Clean code, proper naming, no duplication        │
│ □ Performance: No N+1 queries, efficient operations         │
│ □ Consistency: Matches existing codebase patterns           │
│ □ Types: Proper TypeScript/PHP typing throughout            │
│ □ Error Handling: All errors caught and handled properly    │
└─────────────────────────────────────────────────────────────┘
```

### Step 2: Documentation Validation (Before Completion)

1. **Read relevant documentation** in `docs/` and `docs/adr/`
2. **Compare implementation** against documented behavior
3. **Update outdated docs** if any discrepancies found
4. **Verify examples** still work with new code

### Step 3: Documentation Creation (Always Required)

For EVERY change, create documentation:

1. **Inline docs** - PHPDoc for PHP, JSDoc for TypeScript
2. **Feature docs** - In `docs/` folder for user-facing features
3. **ADR** - In `docs/adr/` for architectural decisions
4. **Type definitions** - Update TypeScript interfaces
5. **README** - Update if setup or usage changes

### Workflow Summary

```
Write Code → Code Review → Validate Against Docs → Create Docs → Tests Pass → Complete
     ↓            ↓                  ↓                  ↓              ↓
  [Code]    [Security,        [Check docs/,      [PHPDoc/JSDoc,  [Pest/Playwright]
            Quality,          ADRs, README]      docs/, ADR,
            Performance]                         README]
```

**Remember: A feature is NOT complete until documentation exists and has been validated.**
